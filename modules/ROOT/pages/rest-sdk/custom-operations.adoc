= Custom Operations
ifndef::env-site,env-github[]
include::../_attributes.adoc[]
endif::[]

== Context

Up to what we saw on previous sections, REST-SDK can pick an API Spec describing backend system endpoints, and automatically assemble equivalent connectivity operations.

Various enrichments could be added with the main purpose of enhancing design time experience, but the functional connectivity is completely defined by the system level functionality described for the SaaS API.

This kind of support falls short to express client oriented consumption experience, whose main purpose is bridging the semantic gap between the user conceptual model and the system conceptual model.

== Defining a connectivity experience from REST-SDK…

The following paragraphs illustrate, by means of a leading example, the process a citizen connectivity developer would go through in order to define a new consumption experience using REST-SDK.

=== … the base connectivity

Since we are following a Layered architecture, the path would start with a given base connectivity.

A fictional SaaS “Offices API” is described by the following RAML API Spec

api.yaml
[source,yaml]
----
#%RAML 1.0

title: Offices API
protocols: [HTTP, HTTPS]
mediaType: application/json
baseUri: http://localhost/office

types:
    Location:
        type: object
        properties:
            location: string
            zone: string
            offset: string
            code: string

/locations:
    post:
        body:
            application/json:
                type: Location
        responses:
            200:
                body:
                    application/json:
                        type: Location
    /{id}:
        description: Location of the office by Id.
        get:
            queryParameters:
              offset?: string
              code:
                type: string
                required: true
            responses:
                200:
                    body:
                        application/json:
                            type: Location
        delete:
            responses:
                204:
----

Base connectivity for Offices API is declared in a REST SDK descriptor offices-descriptor.yaml

offices-descriptor.yaml
[source,yaml]
----
#% Rest Connector Descriptor 1.0

apiSpec:
    url: './api.raml'

connectorName: Offices

connectorGav:
    groupId: com.mulesoft.connectors
    artifactId: offices-api
    version: 1.0.0

defaultInputMediaType: application/json
defaultOutputMediaType: application/json
----

=== … the consumer experience

We will define consumer experience (ie: citizen connectivity) on top of base connectivity.

We Will develop the experience described in the following description (ie: Citizen Connectivity Requirements), containing:

- a definition of the citizen experience domain for consumption
- a functional mapping from citizen domain to the base system domain

We will consider this description as our Product Requirements Document (PRD) for the connector we are required to build.

*OPERATION*
|===
|Operation |Description |Implementation notes

|Find Location
|Find location by its part specification
|Corresponds to a GET on /locations/{id} in system domain
|===

*INPUTS*
|===
|Field |Description |Req | Implementation notes

|Part A
|First part of the identifier of an office location
|true
|auxiliar

|Part B
|Second part of the identifier of an office location
|true
|auxiliar

|
|
|
| Identifer {id} is built as the text “<Part A>-<Part B>”

|
|
|
| Code and Offset are low level data not exposed in this experience since are fixed to code=code-1 and offset=offset-1 in the subdomain we expose.

|===

*OUTPUT*
|===
|Field |Description | Implementation notes

|Location
|Location identifer
|System domain location

|Zone
|Zone for this location
|System domain zone

|
|
| Code and offset from retrieved location is not exposed to user.

|===


*OPERATION*
|===
|Operation |Description |Implementation notes

|Create Location
|Creates a Location
|Corresponds to a POST on /locations
|===

*INPUTS*
|===
|Field |Description |Req | Implementation notes

|Location
|Full identifier of an office location
|true
|auxiliar

|Zone
|Zone for office location
|true
|auxiliar

|
|
|
| Location identifier and zone mapped to corresponding fields.

|
|
|
| Code and Offset are low level data sent as corresponding for this domain code='code-1' and offset='offset-1'.

|===

*OUTPUT*
|===
|Field |Description | Implementation notes

|Location
|Location identifer
|System domain location

|Zone
|Zone for this location
|System domain zone

|
|
| Code and offset from created location is not exposed to user.

|===

The citizen connectivity developer starts implementing this new domain in its own space for declarations, an “Offices Citizen” REST-SDK descriptor…

offices-citizen-descriptor.yaml
[source,yaml]
----
#% Rest Connector Descriptor 1.0

connectorName: Offices Citizen Connector

connectorGav:
   groupId: com.mulesoft.connectors
   artifactId: citizen-offices-api
   version: 1.0.0
----

These declarations act as an overlay on top of system declarations. The composition of them constitute citizen connectivity.

=== ... developing citizen operations

The Citizen Connectivity Requirements define a “Find Location” experience operation in terms of a GET over /locations/{id} endpoint.

We could recur to an endpoint declaration overriding display name and description and let REST SDK generate the natural operation for it (A natural operation would be an operation exposing 1-1 functionality of REST operation)...

[source,yaml]
----
endpoints:
    /locations/{id}:
        operations:
            get:
                displayName: "Find Location"
----

...but then the description goes on describing the expected requirements to be met by inputs and outputs, and they are different from what we can achieve with endpoint declarations.

What we need is something that lets us have much more control in the way this connectivity operation is assembled by REST SDK.

=== ... designing new operations out of single endpoints

==== adding an operations declaration section

We start by adding an operations section in which we are going to define our own operations instead of letting REST-SDK infer them from endpoints.

[source,yaml]
----
#% Rest Connector Descriptor 1.0
#...
operations:
----

...and define a new operation ‘findLocation’ there...

[source,yaml]
----
#% Rest Connector Descriptor 1.0
#...
operations:
    #...
    findLocation:
----

==== ...reuse existing connectivity metadata...

This findLocation is defined as an experience on top of a base connectivity so we will refer to that base connectivity to collect all the metadata defined for it, and then express only the customization that adds the experience we need.

For findLocation as we see in the requirements it is defined in terms of a GET on /locations/{id} endpoint… and we will declare that...

[source,yaml]
----
#% Rest Connector Descriptor 1.0
...
operations:
    ...
    findLocation:
        displayName: Find Location
        description: Find location by its part specification
        base: get/locations/{id}
----

==== ...enrich with display name, description...

We are enriching base operation with a new experience customization so we are adding its own display name and description...

[source,yaml]
----
#% Rest Connector Descriptor 1.0
...
operations:
    ...
    findLocation:
        displayName: Find Location
        description: Find location by its part specification
        base: get/locations/{id}
----

==== ...add custom parameters...

The experience being asked in the requirements refers to inputs we need from a user, that are not part of the base connectivity itself. We define this experience specific inputs as auxiliary parameters by declaring them in a parameters section…

[source,yaml]
----
#% Rest Connector Descriptor 1.0
...
operations:
    ...
    findLocation:
        base: get/locations/{id}
        displayName: Find Location
        description: Find location by its part specification
        parameters:
            partA:
                displayName: part A
                type: string
                required: true
            partB:
                displayName: part B
                type: string
                required: true
----

Note that only the new experience parameters need to be declared here, all the parameterization required by the base connectivity is automatically handled later by REST-SDK.

==== ...customize existing request bindings...

We now need to customize the way those auxiliar inputs are part of the request bindings. In this specific case experience, we want to hide user from dealing with the id of locations giving a more semantic way of building those identifiers.

We also avoid exposing code and offset query parameters from base connectivity since we will be working with a subdomain of data that restricts locations to specific data.

[source,yaml]
----
#% Rest Connector Descriptor 1.0
...
operations:
    ...
    findLocation:
        base: get/locations/{id}
        displayName: Find Location
        description: Find location by its part specification
        parameters:
            partA:
                displayName: part A
                type: string
                required: true
            partB:
                displayName: part B
                type: string
                required: true
        request:
            uriParameter:
                id:
                    value: "#[parameters.partA ++ '-' ++ parameters.partB]"
            queryParameter:
                code:
                    value: code-1
                offset:
                    value: offset-1
----

==== ...brief digression here...

We should note here how these new declarations affect the way REST SDK ends assembling connectivity.

The mechanism used rerlays on the same principle of metadata based declarations and composition that is the foundation of REST-SDK. In fact it is just opening a bit the model REST-SDK uses to interpret and generate connectivity for user declarations so that we can achieve a bit more expressiveness.

Let’s illustrate this in the context of an example...

When we declare connectivity by means of an API spec or descriptor

[source,yaml]
----
endpoints:
  ...
  /locations/{id}:
    operations:
      get:
        expects:
          uriParameter:
            id:
          queryParameter:
            offset:
            code:
----

REST SDK builds an internal model of the entire associated metadata it could gather from those declarations to model and then assemble connectivity for it.

[source,yaml]
----
  getLocationsById:
      request:
          uriParameter:
            id:
          queryParameter:
            offset:
            code:
----

REST SDK finally promotes to operation parameter any unbind request parameter.

[source,yaml]
----
  getLocationsById:
      parameters:
        id: # auto-bind
          type: string
        offset: # auto-bind
          type: string
        code: # auto-bind
          type: string
      request:
          uriParameter:
            id:
              value: "#[parameters.id]"
          queryParameter:
            offset:
              value: "#[parameters.offset]"
            code:
              value: "#[parameters.code]"
----

This internal model is what we call an effective connectivity. A simplification of the interpreted and assembled connectivity in this example would be...


This assembled abstract connectivity is the one that will be eventually used by the generative layer of REST-SDK in order to generate an specific materialization (ie: a Mule connector).

The case for these newly declared operations follow exactly the same approach and are expressed in terms of the same model.

Let’s analyze a bit deeper how this findLocation operation customization ends generating connectivity using the previous model.

The original declaration was...

[source,yaml]
----
operations:
    ...
    findLocation:
        base: get/locations/{id}
        parameters:
            partA:
                displayName: part A
                type: string
                required: true
            partB:
                displayName: part B
                type: string
                required: true
        request:
            uriParameter:
                id:
                    value: "#[parameters.partA ++ '-' ++ parameters.partB]"
            queryParameter:
                offset:
                    value: offset-1
----

This user declaration is then interpreted as a new operation in metadata domain...

[source,yaml]
----
    findLocation:
        base: get/locations/{id}
        parameters:
        request:
----

Since the declared metadata has a base prototype, the expansion of those declarations take place...

[source,yaml]
----
    findLocation:
        request:
          uriParameter:
            id:
          queryParameter:
            offset:
            code:
----

Then the user customizations are processed on top this...

[source,yaml]
----
    findLocation:
        parameters:
          partA:
            type: string
          partB:
            type: string
        request:
            uriParameter:
              id:
                value: "#[parameters.partA ++ '-' ++ parameters.partB]"
            queryParameter:
              offset:
                value: offset-1
              code:
----

Finally promotes any unbind parameter just like before...

[source,yaml]
----
    findLocation:
        parameters:
          code: # auto-bind
            type: string
          partA:
            type: string
          partB:
            type: string
        request:
          uriParameter:
            id:
              value: "#[parameters.partA ++ '-' ++ parameters.partB]"
          queryParameter:
            offset:
              value: offset-1
            code:
              value: "#[parameters.code]"
----

This is the effective interpreted operation that REST-SDK will be using in order to generate connectivity.

With these considerations in mind, let’s resume the original exercise...

==== ...customize response...

As much as the PRD determines the experience on the input required from the user, it also adds it’s requirements for the outputs.

We are asked to hide from user those code and offset fields, so we are declaring a way to customize how the response we want is built out of the base response.

We do this by declaring how we want to interpret the REST response from the response of the actual request made.

[source,yaml]
----
#% Rest Connector Descriptor 1.0
...
operations:
    ...
    findLocation:
        base: get/locations/{id}
        displayName: Find Location
        description: Find location by its part specification
        parameters:
            partA:
                displayName: part A
                type: string
                required: true
            partB:
                displayName: part B
                type: string
                required: true
        request:
            uriParameter:
                id:
                    value: "#[parameters.partA ++ '-' ++ parameters.partB]"
            queryParameter:
                code:
                    value: code-1
                offset:
                    value: offset-1
        response:
            body:
                schemaType: result-schema.type
                value: "#[payload -- ['code', 'offset']]"
----

With this we have finished the first experience requested.

For the second operation, we follow the same approach, but now we are defining experience on top of a POST operation...

==== ...customize existing request body binding...

So we define a way to assemble the body in terms of input data we want to be provided by the user.

[source,yaml]
----
#% Rest Connector Descriptor 1.0
...
operations:
    ...
    findLocation:
      ...
    createLocation:
        base: post/locations
        displayName: Create Location
        description: Creates a location
        parameters:
            location:
                displayName: Location
                type: string
                required: true
            zone:
                displayName: Zone
                type: string
                required: true
        request:
            body:
                value: "#[
                {
                   'location': parameters.location,
                   'zone': parameters.zone,
                   'offset': 'offset-1',
                   'code': 'code-1'
                }]"
        response:
            body:
                typeSchema: ./create-location-output-body-schema.json
                mediaType: application/json
                value: "#[payload -- ['code', 'offset']]"
----

Of course we have complete control on the way this data is offered by the user.

So as much as a set of auxiliary top level parameters we can perfectly have done it using a richer structure...

[source,yaml]
----
#% Rest Connector Descriptor 1.0
...
operations:
    ...
    findLocation:
      ...
    createLocation:
        base: post/locations
        displayName: Create Location
        description: Creates a location
        parameters:
            content:
                displayName: Body
                typeSchema: ./create-location-input-body-schema.json
                mediaType: application/json
                required: true
        request:
            body:
                value: "#[
                {
                   'location': parameters.content.location,
                   'zone': parameters.content.zone,
                   'offset': 'offset-1',
                   'code': 'code-1'
                }]"
        response:
            body:
                typeSchema: ./create-location-output-body-schema.json
                mediaType: application/json
                value: "#[payload -- ['code', 'offset']]"
----

And with these two operation customizations we have completed the exercise asked in the PRD for defining connectivity experience on top of an underlying system connectivity.


== Use cases

I this next section we are covering a couple of common patterns present when developing experience connectivity.

=== reusing same endpoint for two operations

With operation customizations we can define as much operation variations of a top level endpoint operation as we want.

In this specific example we are building two operations, createContact and updateContact, on top of a base endpoint operation updateOrCreateContacts...

Our createContact operation...

[source,yaml]
----
operations:
    createContact:
        base: updateOrCreateContacts
        displayName: Create Contact
        description: Create contact
        parameters:
            CreateContactContent:
                displayName: Content
                typeSchema: ./schemas/CreateContact-Request-Content-schema.json
                mediaType: application/json
                required: true
        request:
            queryParameter:
                summarizeErrors:
                    value: "#[true]"
            body:
                language: "dw"
                expression: "#[
                var contact = parameters.CreateContactContent.Contact
                var address = contact.Address default null
                var phone = contact.Phone default null
                var contactPerson = contact.ContactPerson default null
                ---
                {
                    \"Contacts\": [
                        {
                            (contact.&Name),
                            (contact.&ContactNumber),
                            (contact.&ContactStatus),
                            (contact.&FirstName),
                            (contact.&LastName),
                            (contact.&EmailAddress),
                            (contact.&SkypeUserName),
                            (contact.&BankAccountDetails),
                            (contact.&TaxNumber),
                            (contact.&AccountsReceivableTaxType),
                            (contact.&AccountsPayableTaxType),
                            (if (address != null) {
                            Addresses: [
                            {
                                (address.&AddressType),
                                (address.&AddressLine1),
                                (address.&AddressLine2),
                                (address.&AddressLine3),
                                (address.&AddressLine4),
                                (address.&City),
                                (address.&Region),
                                (address.&PostalCode),
                                (address.&Country),
                                (address.&AttentionTo)
                            }
                            ]} else {}),
                            (if (phone != null) {
                            Phones:  [
                            {
                                (phone.&PhoneType),
                                (phone.&PhoneNumber),
                                (phone.&PhoneAreaCode),
                                (phone.&PhoneCountryCode)
                            }
                            ]} else {}),
                            (contact.&DefaultCurrency),
                            (if (contactPerson != null) {
                            ContactPersons:  [
                                {
                                    (contactPerson.&FirstName),
                                    (contactPerson.&LastName),
                                    (contactPerson.&EmailAddress),
                                    (contactPerson.&IncludeInEmails)
                                }
                            ]} else {})
                        }
                    ]
                }
                ]"
        response:
            body:
                typeSchema: ./schemas/CreateContact-Response-schema.json
                mediaType: application/json
                expression: "#[
                var contact = payload.Contacts[0] default null
                ---
                {
                    (if (contact != null) {
                    Contact:
                        {
                            (contact.&Name),
                            (contact.&ContactID),
                            (contact.&ContactNumber),
                            (contact.&ContactStatus)
                        }
                    } else {})
                }
                ]"

----

And the updateContact operation...

[source,yaml]
----
    updateContact:
        base: updateOrCreateContacts
        displayName: Update Contact
        description: Update contact
        parameters:
            UpdateContactContent:
                displayName: Content
                typeSchema: ./schemas/UpdateContact-Request-Content-schema.json
                mediaType: application/json
                required: true
        request:
            queryParameter:
                summarizeErrors:
                    value: "#[true]"
            body:
                language: "dw"
                expression: "#[
                var contact = parameters.UpdateContactContent.Contact
                var address = contact.Address default null
                var phone = contact.Phone default null
                var contactPerson = contact.ContactPerson default null
                ---
                {
                    \"Contacts\": [
                        {
                            (contact.&Name),
                            (contact.&ContactNumber),
                            (contact.&ContactStatus),
                            (contact.&FirstName),
                            (contact.&LastName),
                            (contact.&EmailAddress),
                            (contact.&SkypeUserName),
                            (contact.&BankAccountDetails),
                            (contact.&TaxNumber),
                            (contact.&AccountsReceivableTaxType),
                            (contact.&AccountsPayableTaxType),
                            (if (address != null) {
                            Addresses: [
                            {
                                (address.&AddressType),
                                (address.&AddressLine1),
                                (address.&AddressLine2),
                                (address.&AddressLine3),
                                (address.&AddressLine4),
                                (address.&City),
                                (address.&Region),
                                (address.&PostalCode),
                                (address.&Country),
                                (address.&AttentionTo)
                            }
                            ]} else {}),
                            (if (phone != null) {
                            Phones:  [
                            {
                                (phone.&PhoneType),
                                (phone.&PhoneNumber),
                                (phone.&PhoneAreaCode),
                                (phone.&PhoneCountryCode)
                            }
                            ]} else {}),
                            (contact.&DefaultCurrency),
                            (if (contactPerson != null) {
                            ContactPersons:  [
                                {
                                    (contactPerson.&FirstName),
                                    (contactPerson.&LastName),
                                    (contactPerson.&EmailAddress),
                                    (contactPerson.&IncludeInEmails)
                                }
                            ]} else {})
                        }
                    ]
                }
                ]"
        response:
            body:
                typeSchema: ./schemas/UpdateContact-Response-schema.json
                mediaType: application/json
                expression: "#[
                var contact = payload.Contacts[0] default null
                ---
                {
                    (if (contact != null) {
                    Contact:
                        {
                            (contact.&Name),
                            (contact.&ContactID),
                            (contact.&ContactNumber),
                            (contact.&ContactStatus)
                        }
                    } else {})
                }
                ]"

----

=== Hiding top level parameters

We can also hide from the connectivity experience, low level parameters that we do not want to be surfacing the high level operation.

[source,yaml]
----

    findLocation:
        base: GET-/locations/{id}
        displayName: Find Location
        description: This is my own find location
        parameters:
            #...
        request:
            #...
            queryParameter:
                code:
                    ignored: true
                offset:
                    ignored: true
        #...

----

Note the difference from doing this in the customized operation instead of on the base operation that would affect not only this customized operation but also the base operation.

=== Changing a parameters to a default literal value

We can hide it from the connectivity experience but including it in requests with a literal value.

[source,yaml]
----

    findLocation:
        base: GET-/locations/{id}
        displayName: Find Location
        description: This is my own find location
        parameters:
            #...
        request:
            #...
            queryParameter:
                code:
                    value: AA1231
                offset:
                    value: ZZZ399
        #...

----

=== Removing input/output fields

We can as well define which are the fields we want to expose to the final user defining a new reshaped version of the base connectivity request body.

In this case for example we are hiding the ContactStatus field since we are only allowing creating ACTIVE users.

Note that this reshaped schema is specified in the auxiliar parameter typeSchema.

[source,yaml]
----
    updateContact:
        base: updateOrCreateContacts
        displayName: Update Contact
        description: Update contact
        parameters:
            UpdateContactContent:
                displayName: Content
                ## ...
                typeSchema: ./schemas/UpdateContact-Request-Content-schema.json
                mediaType: application/json
                required: true
        request:
            body:
                language: "dw"
                expression: "#[
                var contact = parameters.UpdateContactContent.Contact
                ---
                {
                    (contact.&Name),
                    (contact.&ContactNumber),
                    (contact.&FirstName),
                    (contact.&LastName),
                    // ...
                    ContactStatus: \"ACTIVE\",
                }
                ]"
        response:
            body:
                ## ...
----

Same thing applies also to output fields as we can see in the following customized operation that hides code and offset from the response to the user.

[source,yaml]
----
    createLocation:
        base: POST-/locations
        displayName: Create Location
        description: This is my own create location with content
        parameters:
            content:
                displayName: Body
                typeSchema: ./location-schema.json
                mediaType: application/json
                required: true
        request:
            ## ...
        response:
            body:
                ##
                typeSchema: ./location-schema.json
                mediaType: application/json
                expression: "#[payload - 'code' - 'offset']"
----

=== Transforming input/output types

We can also have more complex transformations between input/output auxiliar parameters and the actual request/response binding parameters.

[source,yaml]
----
    searchContacts:
        base: getContacts
        displayName: Search Contacts
        description: Search Contacts
        parameters:
            ContactName:
                displayName: Contact Name
                description: The name of contact
                type: string
                required: false
            ContactEmailAddress:
                displayName: Contact Email Address
                description: The email address  of the contact
                type: string
                required: false
            ContactAccountNumber:
                displayName: Contact Account Number
                description: The account number of the contact
                type: string
                required: false
        request:
            queryParameter:
                where:
                    value: "#[
                        %dw 2.0
                        output application/json
                        var ContactName = parameters.ContactName default null
                        var ContactEmailAddress = parameters.ContactEmailAddress default null
                        var ContactAccountNumber = parameters.ContactAccountNumber default null
                        ---
                        {
                            (if (ContactName != null) {Name: ContactName} else {} ),
                            (if (ContactEmailAddress != null) {EmailAddress: ContactEmailAddress} else {} ),
                            (if (ContactAccountNumber != null) {AccountNumber: ContactAccountNumber} else {} )
                        }
                        pluck ((value, key, index) -> key ++ \"=\\\"\" ++ value ++ \"\\\"\") joinBy \" AND \"
                    ]"
        response:
            bodyParts:
                main:
                    typeSchema: ./schemas/SearchContacts-Response-schema.json
                    mediaType: application/json
                    value: "#[
                        {
                            Contacts: payload.Contacts map (contact, index) ->
                                {
                                    (contact.&ContactID),
                                    (contact.&Name),
                                    (contact.&ContactNumber),
                                    (contact.&ContactStatus),
                                    (contact.&FirstName),
                                    (contact.&LastName),
                                    (contact.&EmailAddress),
                                    (contact.&SkypeUserName),
                                    (contact.&BankAccountDetails),
                                    (contact.&TaxNumber),
                                    (contact.&AccountsReceivableTaxType),
                                    (contact.&AccountsPayableTaxType),
                                    (contact.&Addresses),
                                    (contact.&Phones),
                                    (contact.&DefaultCurrency),
                                    (contact.&ContactPersons)
                                }
                        }
                    ]"
----

== Single Using declarative sidecars

We can also be able to generate this customized operations using declarative sidecars on the generated connector when including base and experience connectivity in the same artifact.

The sidecarOperations directive generates all customized operations as sidecars. Directive is scoped for the descriptor. Its default value is false.

[source,yaml]
----
##
sidecarOperations: true

operations:
    getContactByID:
        base: getContact
        displayName: Get Contact By ID
        description: Get contact by ID
        parameters:
            ContactID:
                displayName: ContactID
                type: string
                required: true
        request:
            uriParameter:
                ContactID:
                    value: "#[parameters.ContactID]"
        response:
            bodyParts:
                main:
                    typeSchema: ./schemas/GetContactByID-Response-schema.json
                    mediaType: application/json
                    value: "#[
                    var contact = payload.Contacts[0] default null
                    ---

                    {
                        (if (contact != null) {
                        Contact:
                            {
                                (contact.&ContactID),
                                (contact.&Name),
                                (contact.&ContactNumber),
                                (contact.&ContactStatus),
                                (contact.&FirstName),
                                (contact.&LastName),
                                (contact.&EmailAddress),
                                (contact.&SkypeUserName),
                                (contact.&BankAccountDetails),
                                (contact.&TaxNumber),
                                (contact.&AccountsReceivableTaxType),
                                (contact.&AccountsPayableTaxType),
                                (contact.&Addresses),
                                (contact.&Phones),
                                (contact.&DefaultCurrency),
                                (contact.&ContactPersons)
                            }
                        } else {})
                    }
                    ]"

----

== Reference

The following is a full reference of the constructions available to define customized operations.

*ConnectorDescriptor*
|===
|Field |Type |Description

|...
|
|

|operations
|OperationCustomization[]
|Section for adding new operations to connectivity descriptor.
|===

*OperationCustomization*
|===
|Field |Type |Description

|name
|string
|Name for the operation.

|base
|string
|Prototype endpoint from where to capture base metadata

|displayName
|string
|Display name for operation.

|description
|string
|Description for operation.

|parameters
|OperationCustomizationParameter[]
|List of auxiliar parameters needed for the supported experience.

|request
|OperationCustomizationRequest
|Customization of request on underlying connectivity.

|response
|OperationCustomizationResponse
|Customization of response obtained from underlying connectivity.

|pagination
|string
|Pagination to use on operation.

|sampleData
|SampleDataExpression
|Sample data to use on operation.
|===


*OperationCustomizationParameter*
|===
|Field |Type |Description

|name
|string
|Name for the auxiliar parameter.

|displayName
|string
|Display name for the auxiliar parameter.

|description
|string
|Description for the auxiliar parameter.

|required
|boolean
|Optionality for the auxiliar parameter.

|default
|string
|Default value for the auxiliar parameter.

|type
|String enum simple types
|Primitive type for parameter. Exclusive with Schema Type.

|schemaType
|string
|Schema specifying parameter value shape. Exclusive with Type.

|mediaType
|string
|Media type to be used for value interpretation for schema defined parameters.

|valueProvider
|ValueProviderExpression
|Provider of dynamic values  for this parameter.
|===

*OperationCustomizationRequest*
|===
|Field |Type |Description

|uriParameter
|OperationCustomizationRequestParameter[]
|Uri parameter customizations on the request.

|queryParameter
|OperationCustomizationRequestParameter[]
|Query parameter customizations on the request.

|header
|OperationCustomizationRequestParameter[]
|Header parameter customizations on the request.

|multipartBody
|OperationCustomizationRequestParameter[]
|Multipart body parameter customizations on the request.

|body
|Expression
|Body bind expression or literal value to use on request.

|===

*OperationCustomizationRequestParameter*
|===
|Field |Type |Description

|name
|string
|Name for request parameter.

|displayName
|string
|Display name for request parameter.

|description
|string
|Description for request parameter.

|ignored
|boolean
|Inclusion on request parameter.

|required
|boolean
|Optionality for request parameter.

|type
|String enum simple types
|Primitive type for parameter. Exclusive with Schema Type.

|schemaType
|string
|Schema specifying parameter value shape. Exclusive with Type.

|mediaType
|string
|Media type to be used for value interpretation for schema defined parameters.

|valueProvider
|ValueProviderExpression
|Provider of dynamic values  for this parameter.

|value
|Expression
|Expression or literal value to bind on request parameter.
|===

*OperationCustomizationResponse*
|===
|Field |Type |Description

|header
|OperationCustomizationResponseParameter[]
|Header parameter customizations on the response.

|multipartBody
|OperationCustomizationResponseParameter[]
|Multi part body customizations on the response.

|body
|Expression
|Body bind expression or literal value to use on response.
|===

*OperationCustomizationResponseParameter*
|===
|Field |Type |Description

|name
|string
|

|type
|String enum simple types
|Primitive type for parameter. Exclusive with Schema Type.

|schemaType
|string
|Schema specifying parameter value shape. Exclusive with Type.

|mediaType
|string
|Media type to be used for value interpretation for schema defined parameters.

|value
|Expression
|Expression or literal value to bind on response parameter.
|===

